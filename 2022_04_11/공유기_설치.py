#백준 2110번 (이분탐색, 골드5)
'''
일반적으로 이문제를 완탐 돌리면, 두 공유기 사이의 거리를 1일떄, 2일때 ... 이런식으로 돌릴수도 있지만, 데이터의 개수가 많기 때문에, 어렵다
이렇게 특정한 값을 찾을 떄 빠르게 탐색이 가능한 것이 이진탐색이다
이진탐색의 경우, 정렬이 되어있어야되는데,마침 집의 위치좌표를 주었기 때문에 정렬를 해야만 한다.
문제 접근은 다음과 같다
1. 최소 공유기 사이 거리와, 최대 공유기 사이 거리를 구한다.
2. 거리르 1,2,3이렇게 순차적으로 탐색하는 것이 아닌, 1에서 구한 거리를 이진탐색을 통해서 중간값을 선정한다.
3. 선정했으면, 앞에집(좌표상으로 작은 값)부터 공유기를 설치한다
4. 설치의 경우 맨 첫번째 집(인덱스 0)을 기준으로 해서, 반복문으로 한칸씩 증가시켜나가면서, 기준집과 거리를 구한다.
5. 2에서 이진탐색으로 구한 중간거리 값을 넘어가는지, 안넘어가는지를 확인해서, 넘어가면, 해당위치에 공유기를 세운다.
6. 해당 위치에 공유기를 세웠으면, 기준을 그 위치로 잡고, ㄲ끝까지 탐색해본다.
7. 이렇게 공유기를 다 세워보고, 세운 공유기와, 세울수 있는(입력으로 주어진) 공유기 개수를 비교한다.
8. 만약 세운 (공유기 수) > (세울수 있는 공유기 수)  이면, 더 넓게 세워도 된다는 뜻이다(예를 들어 4로 세울때 5개를 세웠다면, 거리를 6으로 늘려서 세우면 훨씬 적게 세울수 있다.)
9. 만약 (공유기 수) < (세울수 있는 공유기 수) 이면, 더 좁게 세워야 된다는 뜻이다.(예를 들어 3으로 세울떄 5개를 세웠다면, 거리를 2로 놓고 세우면 5보다 더 촘촘하게 많이 세울것이다.)
10. 따라서 8번의 경우에는, 이분탐색에서 mid를 +1 하고 start값에 넣어, 거리후보를 더 크게 잡고, 9번의 경우 mid-1을 end에 넣어 거리 후보를 더 작게 잡도록 해서 최대가 되는 값을 찾아야 된다.

(이진탐색으로 뽑은 거리 후보는, 최소임 - 즉, 탐색중에  딱 이거리가 아닌, 이보다 큰거리를 전부 카운트하는 식으로 계산해야됨)
'''
import sys


n,c = map(int,sys.stdin.readline().split())

num_list = list()

for _ in range(n):
    num_list.append(int(sys.stdin.readline()))

#이진 탐색은 정렬되어 있어야됨
num_list.sort()

result = 0

def binary_search(start,end):
    global result
    while start<=end:
        #거리 후보로 최대,최소값의 중간 값 구하기
        mid = (start+end)//2

        #기준 값 잡기
        current_loc = num_list[0]

        #공유기 개수 - 기준이 되는 첫번쨰 위치는 이미 설치함
        temp_count = 1

        #앞에서 부터 mid값 보다 큰 위치가 나오면 공유기 설치
        for i in range(1,n):

            #공유기거리가, 거리 후보보다 클떄만 설치
            if num_list[i] - current_loc >= mid:
                temp_count +=1
                #설치했으니 기준값 업데이트
                current_loc = num_list[i]
            

        #공유기 설치가 완료되면, 입력으로 받은 설치 가능개수와 비교(c)
        #일단 설치 가능한 개수와 같거나 더 많으면, 일단은 개수를 저장하고 있음
        #최대로 만들기 위해서 같던지 더 많으면, 거리를 늘려서 해봄
        if temp_count >= c:
            result = mid
            #다음 거리 후보군을 위해 업데이트 - 더 크게 잡아야 됨
            start = mid +1

        #개수가 부족하면 더 늘려서 다시해봐야됨
        else:
            end = mid-1

    
binary_search(1,num_list[-1] - num_list[0])

print(result)


            




