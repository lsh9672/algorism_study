> ### 버블정렬

- 인접한 두개의 데이터를 비교해서 작은 값을 인덱스가 빠른쪽으로 바꾸는 식으로 정렬하는 방법을 말한다.

- 3 1 이와 같이 두개를 비교한다 가정하면 3 >1 이므로 둘의 자리를 바꾸는 것이다.

- 예

```
[3,2,5,4] (3과2 비교)-> [2,3,5,4] (3과5 비교)-> [2,3,5,4] (5와 4 비교) -> [2,3,4,5]
```

- 시간복잡도가 O(n^2) 이므로 빠른 알고리즘은 아니다.

> ### 삽입정렬

- 삽입정렬은 두번째 인덱스 부터 시작하는 알고리즘이다.

- 두번째 인덱스의 값과 앞의 인덱스의 값들과 비교해서 자신이 더 작다면 해당 값의 앞으로 자리를 옮기는 것이다.

- 예

```
[5,4,3,9] (4부터 시작)-> [4,5,3,9] (3과 앞의 값들 비교) -> [3,4,5,9]
```

- 이 또한 버블정렬과 마찬가지로 시간복잡도가 O(n^2) 이므로 빠른 알고리즘은 아니다.

> ### 선택정렬

- 앞에서부터 값을 한개 씩 선택하고, 그 뒤의 모든 값들과 순차적으로 비교해서 가장작은 값과 자리를 바꾸는 식으로 정렬하는 알고리즘이다.

- 예

```
[3,5,6,1] -> 처음으로 3을 선택하고, 해당값을 포함한 인덱스상 뒤에 있는 값들과 전부 비교해서 가장 작은 값을 찾고, 교체 해준다.
[1,5,6,3] -> 두번째 인덱스인 5를 선택하고 5를 포함한 인덱스상 뒤에 있는 값(5,6,3)중에 가장 작은 값과 교체 한다.
[1,3,6,5]
[1,3,5,6]
```

- 이 또한 시간복잡도가 O(n^2)이 나오는 알고리즘으로 성능이 좋은 알고리즘은 아니다.

- 각 알고리즘의 동작은 아래 링크에서 볼수 있다.

  https://visualgo.net/en/sorting

- 참고로 파이썬과 자바에서 쓰는 sort() 의 경우에는 insertion sort와 뒤에서 정리할 merge sort 결합해서 만든 tim sort라는 알고리즘으로 메모리를 추가로 사용했지만 최선의 경우 O(n), 최악의 경우 O(nlogn)이 나오는 아주 괜찮은 알고리즘이다.

- 가급적이면 직접 정렬을 구현하는 것이 아닌 sort()쓰는 편이 대부분의 경우에 성능이 좋게 나온다.
