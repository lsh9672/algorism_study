> ### 재귀

- 함수안에서 자기자신(함수)를 호출하는 형태이다.

- 시간복잡도나 공간복잡도 측면으로 봐도 좋은 방법이 아님

- 파이썬의 경우 재귀호출의 횟수를 1000으로 제한하고 있음

- 재귀의 경우 함수 호출시마다 스택에 넣게 되는데 파이썬은 이 스택의 크기를 1000으로 제한해둠

```python

#대표적인 예제 - 팩토리얼
#fac이라는 함수안에서 fac이라는 함수를 호출하고 있다.
def fac(num):
    if num > 1:
        return num * fac(num-1)
    else:
        return num
```

> ### 분할정복

- 복잡한 문제를 풀때, 문제를 분할해서 각각을 풀고 합쳐서 문제를 해결하는 방법

- 문제를 나눌수 없을때 까지 나눠서 문제를 해결한다.

- 하향식 방법으로 상위의 해답을 알기 위해 하위의 문제로 쪼개 나가면서 답을 알아가는 방식

- 동적계획법과 다른점은 문제를 쪼갤때 쪼개진 부분 문제는 서로 중복이 되지 않음

- 대표적인 예 : 퀵정렬, 병합정렬

> ### 동적 계획법

- 더이상 쪼갤수 없는 가장 작은 부분의 문제들을 해결하고 그것들의 값을 이용해서 더 상위의 문제를 풀어나가는 방식

- 상향식 방법을 이용함

- Memoization기법을 이용해서 중복되는 것을 다시 계산하지 않도록 저장하여 실행속도를 올림(메모리를 추가로 써야됨.)

- 분할정복과 다른점은 문제를 쪼갤때 쪼개진 부분의 문제가 중복이 되기 때문에 메모이제이션 기법을 이용해서 중복되는 문제의 답을 저장하는 식으로 해결을 함

- 대표적인 예 : 피보나치 수열

> ### 퀵정렬

- pivot이라고 하는 기준점을 정해서 기준점보다 작은 값은 왼쪽, 큰 값은 오른쪽으로 나열해서 정렬하는 방식

- 완전히 정렬될때까지 왼쪽, 오른쪽의 나열된 값에 이 방법을 반복하기 때문에 재귀가 사용이 됨.

- 리턴 : 왼쪽 + 기준점 + 오른쪽

- pivot은 구현하는 사용자가 원하는대로 정함(첫번째값일수도 있고, 중간값일수도 있음)

- 시간복잡도 : O(nlogn)

  (단 pivot을 맨처음 값으로 잡았을떄 이 값이 가장 크거나 가장 작을경우 모든 값을 탐색하게 되어서 최악의 경우 O(n^2)이 나옴)

> ### 병합정렬

- 정렬

  1.리스트를 절반으로 나눠서 두개의 리스트로 만든다 2. 1번을 나눌수 없을 떄 까지 반복한다. 3. 두 개씩(리스트 두개) 비교를 해서 정렬한다(작은게 앞으로 오도록) 4. 이 과정을 재귀를 이용해서 반복한다.

- 시간 복잡도 : O(nlogn)

- 이 알고리즘의 경우, 현재 파이썬과 자바에서 사용하는 정렬라이브러리인 sort()를 구현하는 tim sort에 사용된 알고리즘이므로 잘 알아두면 좋다.

> ### 이진탐색

- 데이터를 둘로 나눠서 탐색하는 방법

- 이 탐색방법의 경우, 데이터가 정렬이 되어있어야 한다.

- 이진탐색 구현시, 재귀로도 가능하지만 재귀의 경우 시간복잡도와 공간복잡도에 있어서 반복문으로 구현하는 것보다 성능이 떨어지기 때문에 반복문으로 구현하는 것이 좋다.

- 시간복잡도 : O(logn)
